# This script was generated by OpenMM-Setup on 2019-02-15.
import sys
import glob
from simtk.openmm import *
from simtk.openmm.app import *
from simtk.unit import *
from sys import stdout

# command_line variables
swarm_number = sys.argv[1]
traj_number = sys.argv[2]
starting_structure = str(sys.argv[3])
subjob_number = sys.argv[4]

base_name="./swarm%s_traj%s_subjob%s" %(str(swarm_number).zfill(4), str(traj_number).zfill(4),str(subjob_number).zfill(4))
dcd_name="%s.dcd" %(base_name)
log_name="%s.log" %(base_name)
final_pdb_name="%s.pdb" %(base_name)

# Input Files

psf = CharmmPsfFile('ionized.psf')
pdb = PDBFile(starting_structure)
params = CharmmParameterSet('all_top.rtf', 'parameters_all36.prm')

# Compute the box dimensions from the coordinates and set the box lengths (only
# orthorhombic boxes are currently supported in OpenMM)

xsc_file_name = glob.glob('*.xsc')
xsc_file = open(xsc_file_name[0], 'r')
xsc_last_line = xsc_file.read().splitlines()[-1].split(' ')
xsc_file.close()

# Divide by 10 because NAMD xsc is in angstroms, whereas nanometers is the default in openMM
x_PBC_vector_length = float(xsc_last_line[1])/10
y_PBC_vector_length = float(xsc_last_line[5])/10
z_PBC_vector_length = float(xsc_last_line[9])/10
  
psf.setBox(x_PBC_vector_length, y_PBC_vector_length, z_PBC_vector_length)

# System Configuration

nonbondedMethod = PME
nonbondedCutoff = 12*angstroms
switchDistance=10*angstroms

ewaldErrorTolerance = 0.0005
constraints = AllBonds
rigidWater = True
constraintTolerance = 0.000001

# Integration Options

dt = 0.004*picoseconds
temperature = 310*kelvin
friction = 1.0/picosecond

# Simulation Options

steps = 100000
equilibrationSteps = 0
platform = Platform.getPlatformByName('CUDA')
platformProperties = {'DeviceIndex': '0', 'Precision': 'mixed'}
dcdReporter = DCDReporter(dcd_name, 20000)

dataReporter = StateDataReporter(log_name, 2000, totalSteps=steps, step=True, time=True, speed=True, progress=True, elapsedTime=True, remainingTime=True, potentialEnergy=True, kineticEnergy=True, totalEnergy=True, temperature=True, volume=True, density=True, separator=',')

# Prepare the Simulation

print('Building system...')
topology = psf.topology
positions = pdb.positions
system = psf.createSystem(params, nonbondedMethod=PME, nonbondedCutoff=nonbondedCutoff, constraints=constraints, rigidWater=rigidWater, ewaldErrorTolerance=ewaldErrorTolerance, switchDistance=switchDistance, hydrogenMass=4*amu)
system.addForce(MonteCarloMembraneBarostat(1.01325*bar, 0*bar*nanometer, 310*kelvin, MonteCarloMembraneBarostat.XYIsotropic, MonteCarloMembraneBarostat.ZFree))

integrator = LangevinIntegrator(temperature, friction, dt)
integrator.setConstraintTolerance(constraintTolerance)
simulation = Simulation(topology, system, integrator, platform, platformProperties)
simulation.context.setPositions(positions)

# Minimize and Equilibrate

simulation.context.setVelocitiesToTemperature(temperature)
simulation.currentStep = 0

if int(subjob_number) > 0: simulation.loadCheckpoint('checkpnt.chk')

# Simulate
print('Simulating...')
simulation.reporters.append(dcdReporter)
simulation.reporters.append(dataReporter)
simulation.reporters.append(CheckpointReporter('checkpnt.chk', 20000))
simulation.step(steps)
simulation.saveState('final_state_file.xml')

positions = simulation.context.getState(getPositions=True).getPositions()
PDBFile.writeFile(simulation.topology, positions, open(final_pdb_name, 'w'))

os.system('cp checkpnt.chk %s.chk' %base_name)
os.system('cp final_state_file.xml %s_statefile.xml' %base_name)
print("FINISHED")
